import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';
import multer from 'multer';
import fs from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

const prisma = new PrismaClient();

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.resolve(process.cwd(), 'public/uploads'));
  },
  filename: (req, file, cb) => {
    cb(null, uuidv4() + '.webp');
  },
});

const upload = multer({ storage });

export async function POST(req) {
  try {
    const error = await new Promise((resolve, reject) => {
      upload.any()(req, {}, (err) => {
        if (err) {
          console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞:', err);
          reject(err);
        }
        resolve();
      });
    });

    if (error) {
      return new NextResponse("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞", { status: 500 });
    }

    try {
      const formData = await req.formData();
      const view = parseInt(formData.get('view'), 10);
      const like = parseInt(formData.get('like'), 10);
      const article = formData.get('article');
      const publication = formData.get('publication') === 'true';
      const dateTime = formData.get('dateTime');
      const link = formData.get('link');
      const group = formData.get('group');
      const description = formData.get('description');
      
      const imgFiles = formData.getAll('img');
      const fileName = [];
      
      for (const imgFile of imgFiles) {
        const name = uuidv4() + '.webp';
        fileName.push({ image: name });
        const filePath = path.resolve(process.cwd(), 'public/uploads', name);
        const data = await imgFile.arrayBuffer();
        await fs.promises.writeFile(filePath, Buffer.from(data));
      }

      const data = await prisma.articles.create({
        data: {
          view,
          link,
          article,
          like,
          group,
          description,
          publication,
          dateTime,
          img: JSON.stringify(fileName),
        },
      });

      if (data) {
        return NextResponse.json({ message: '–°—Ç–∞—Ç—å—è –¥–æ–±–∞–≤–ª–µ–Ω–∞' });
      }
    } catch (error) {
      console.error("üöÄ POST –û—à–∏–±–∫–∞:", error);
      return new NextResponse("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏", { status: 500 });
    }
  } catch (error) {
    console.error('Error saving data:', error);
    return new NextResponse("–û—à–∏–±–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ", { status: 500 });
  }
}



next-env.d.ts

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.




  const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/otzyvy/all`,{ cache: 'no-store' });
		 
			  if (!response.ok) {
				 throw new Error(`HTTP error! Status: ${response.status}`);
			  }
			  const data = await response.json();
			  console.log("üöÄ üöÄ üöÄ –æ—Ç–≤–µ—Ç! data:", data);